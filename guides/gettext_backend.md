# Gettext Backend - Complete Guide

This guide provides comprehensive documentation for using the Gettext backend with AshPhoenixTranslations.

## Table of Contents

- [Overview](#overview)
- [Message ID Patterns](#message-id-patterns)
- [PO File Structure](#po-file-structure)
- [Runtime Behavior](#runtime-behavior)
- [Pluralization](#pluralization)
- [Translation Contexts](#translation-contexts)
- [Dynamic Translations](#dynamic-translations)
- [Workflow Integration](#workflow-integration)
- [Advanced Features](#advanced-features)
- [Troubleshooting](#troubleshooting)

## Overview

The Gettext backend integrates AshPhoenixTranslations with Phoenix's standard internationalization system. Instead of storing translations in the database, it uses `.po` (Portable Object) files - the industry-standard format for software localization.

### Key Concepts

- **msgid**: Message identifier (unique key for each translation)
- **msgstr**: Message string (the actual translation)
- **domain**: Logical grouping of translations (typically resource name)
- **locale**: Language/region code (en, es, fr, en_US, etc.)
- **.po file**: Plain text file containing translations
- **.pot file**: Template file for generating translations

## Message ID Patterns

### Resource-Based Pattern

AshPhoenixTranslations generates message IDs using a consistent pattern:

```elixir
"<resource_module>.<attribute_name>"
```

**Examples:**

```elixir
defmodule MyApp.Shop.Product do
  translations do
    translatable_attribute :name, :string
    translatable_attribute :description, :text

    backend :gettext
  end
end

# Generated msgids:
# - "product.name"
# - "product.description"
```

### Domain Inference

The domain is derived from the resource module name:

- `MyApp.Shop.Product` → domain: `"product"`
- `MyApp.Accounts.User` → domain: `"user"`
- `MyApp.Blog.Post` → domain: `"post"`

### Custom Message IDs

For fine-grained control, you can specify custom msgids:

```elixir
translations do
  translatable_attribute :name, :string,
    msgid: "custom.product.title"  # Override default
end
```

## PO File Structure

### File Location

```
priv/gettext/
├── en/
│   └── LC_MESSAGES/
│       ├── default.po      # General translations
│       ├── product.po      # Product resource translations
│       └── user.po         # User resource translations
├── es/
│   └── LC_MESSAGES/
│       ├── default.po
│       ├── product.po
│       └── user.po
└── product.pot             # Template file
```

### Complete PO File Format

```po
## priv/gettext/es/LC_MESSAGES/product.po
##
## This file is a PO Template file.
##
## `msgid`s here are often extracted from source code.
## Add new translations manually only if they're dynamic
## translations that can't be statically extracted.
##
## Run `mix gettext.extract` to bring this file up to
## date. Leave `msgstr`s empty as changing them here has no
## effect: edit them in PO (`.po`) files instead.

msgid ""
msgstr ""
"Language: es\n"
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
"Content-Type: text/plain; charset=UTF-8\n"

## Resource field translations

# Product name translation
#: lib/my_app/shop/product.ex:10
msgid "product.name"
msgstr "Nombre del Producto"

# Product description translation
#: lib/my_app/shop/product.ex:11
msgid "product.description"
msgstr "Descripción del Producto"

# With translator comments
# TRANSLATORS: This is the product SKU (Stock Keeping Unit)
#: lib/my_app/shop/product.ex:12
msgid "product.sku"
msgstr "Código de Producto"

# With context (explained in Translation Contexts section)
msgctxt "short_form"
msgid "product.name"
msgstr "Nombre"
```

### Header Components

#### Language Declaration

```po
"Language: es\n"
```

Specifies the target language for this translation file.

#### Plural Forms

```po
"Plural-Forms: nplurals=2; plural=(n != 1);\n"
```

Defines how pluralization works for this language:
- `nplurals=2`: Two plural forms (singular/plural)
- `plural=(n != 1)`: Formula for selecting the form

Examples for different languages:

```po
# English: 2 forms (one/other)
"Plural-Forms: nplurals=2; plural=(n != 1);\n"

# French: 2 forms (same as English)
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

# Polish: 3 forms (one/few/many)
"Plural-Forms: nplurals=3; plural=(n==1 ? 0 : n%10>=2 && n%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"

# Japanese: 1 form (no plurals)
"Plural-Forms: nplurals=1; plural=0;\n"
```

#### Character Encoding

```po
"Content-Type: text/plain; charset=UTF-8\n"
```

Always use UTF-8 for proper international character support.

### Comment Types

#### Extracted Comments

```po
#: lib/my_app/shop/product.ex:10
```

Automatically generated by extraction tools. Shows source location.

#### Translator Comments

```po
# TRANSLATORS: This is important context for translators
msgid "product.name"
msgstr "Nombre"
```

Manual comments for translation guidance.

#### Reference Comments

```po
#. This comment stays with the msgid
msgid "product.name"
msgstr "Nombre"
```

Developer comments explaining the usage.

#### Flags

```po
#, elixir-format
msgid "product.name"
msgstr "Nombre"
```

Special flags for processing (e.g., formatting hints).

## Runtime Behavior

### Translation Resolution

When you access a translatable attribute, the Gettext backend:

1. Determines the current locale from context
2. Constructs the msgid (`"resource.attribute"`)
3. Calls `Gettext.dgettext(module, domain, msgid)`
4. Returns the translated string or fallback

**Code Flow:**

```elixir
# User requests Spanish translation
product = MyApp.Shop.Product |> Ash.read_one!()

# With locale context
AshPhoenixTranslations.translate(product, :name, :es)

# Internal resolution:
# 1. msgid = "product.name"
# 2. domain = "product"
# 3. Gettext.dgettext(MyAppWeb.Gettext, "product", "product.name", %{}, locale: :es)
# 4. Returns "Nombre del Producto" from priv/gettext/es/LC_MESSAGES/product.po
```

### Fallback Chain

If a translation is missing, Gettext follows this fallback chain:

1. **Requested locale**: `es_MX` (Spanish - Mexico)
2. **Base locale**: `es` (Spanish - generic)
3. **Default locale**: `en` (English - configured default)
4. **msgid itself**: `"product.name"` (last resort)

**Configuration:**

```elixir
# config/config.exs
config :my_app, MyAppWeb.Gettext,
  default_locale: "en",
  locales: ~w(en es fr de),
  fallback_locale: "en"
```

### Calculation Integration

The GettextTranslation calculation module provides the bridge:

```elixir
# Automatically generated by transformers
calculation :name,
  type: :string,
  calculation: {AshPhoenixTranslations.Calculations.GettextTranslation,
    attribute_name: :name,
    locales: [:en, :es, :fr],
    backend: :gettext,
    gettext_module: MyAppWeb.Gettext,
    domain: "product"
  }
```

**Runtime execution:**

```elixir
product
|> Ash.load!([:name], context: %{locale: :es})
# Triggers GettextTranslation.calculate/3
# Returns translated value from .po file
```

### Compile-Time vs Runtime

**Compile-Time Operations:**
- Extract msgids from resources: `mix ash_phoenix_translations.extract`
- Generate .pot template files
- Compile .po files to .beam: `mix compile.gettext`

**Runtime Operations:**
- Locale resolution from context
- Translation lookup from compiled tables
- Fallback chain traversal
- Pluralization formula application

## Pluralization

### Basic Plural Forms

Gettext supports complex pluralization rules:

```elixir
# In your resource
translations do
  translatable_attribute :items_count, :string,
    plural: true
end
```

**PO file:**

```po
# English plurals
msgid "product.items_count"
msgid_plural "product.items_count_plural"
msgstr[0] "%{count} item"
msgstr[1] "%{count} items"

# French plurals (n=0 or n=1 use form 0, else form 1)
msgid "product.items_count"
msgid_plural "product.items_count_plural"
msgstr[0] "%{count} article"
msgstr[1] "%{count} articles"

# Polish plurals (3 forms)
msgid "product.items_count"
msgid_plural "product.items_count_plural"
msgstr[0] "%{count} przedmiot"    # n=1
msgstr[1] "%{count} przedmioty"   # n%10 in 2..4 && n%100 not in 12..14
msgstr[2] "%{count} przedmiotów"  # other
```

### Using Pluralized Translations

```elixir
# In your view
<%= dngettext(
  "product",
  "product.items_count",
  "product.items_count_plural",
  count,
  count: count
) %>

# Runtime examples:
# count=0: "0 items" (English), "0 articles" (French)
# count=1: "1 item" (English), "1 article" (French)
# count=5: "5 items" (English), "5 articles" (French)
```

### Complex Pluralization

Some languages have complex rules:

```po
# Arabic: 6 plural forms!
"Plural-Forms: nplurals=6; plural=(n==0 ? 0 : n==1 ? 1 : n==2 ? 2 : n%100>=3 && n%100<=10 ? 3 : n%100>=11 ? 4 : 5);\n"

msgid "product.items_count"
msgid_plural "product.items_count_plural"
msgstr[0] "لا عناصر"           # 0 items
msgstr[1] "عنصر واحد"          # 1 item
msgstr[2] "عنصران"             # 2 items
msgstr[3] "%{count} عناصر"     # 3-10 items
msgstr[4] "%{count} عنصرًا"    # 11-99 items
msgstr[5] "%{count} عنصر"      # 100+ items
```

## Translation Contexts

Contexts disambiguate translations with identical msgids:

### Use Cases

- Same word with different meanings
- Gender-specific translations
- Formal vs informal variants

### Example

```po
# Default context
msgid "product.status"
msgstr "Estado"

# Short form context
msgctxt "short_form"
msgid "product.status"
msgstr "Est."

# Abbreviated context
msgctxt "abbrev"
msgid "product.status"
msgstr "E"
```

### Usage in Code

```elixir
# Default context
Gettext.dgettext(MyAppWeb.Gettext, "product", "product.status")
# Returns: "Estado"

# Specific context
Gettext.dpgettext(MyAppWeb.Gettext, "product", "short_form", "product.status")
# Returns: "Est."
```

## Dynamic Translations

### Variable Interpolation

Embed variables in translations:

```po
msgid "product.price_display"
msgstr "Price: €%{amount}"

msgid "product.stock_status"
msgstr "Only %{count} left in stock!"
```

**Usage:**

```elixir
Gettext.dgettext(
  MyAppWeb.Gettext,
  "product",
  "product.price_display",
  amount: product.price
)
# Returns: "Price: €29.99"
```

### Complex Formatting

```po
msgid "product.created_info"
msgstr "Created by %{user} on %{date} at %{time}"
```

**Usage:**

```elixir
Gettext.dgettext(
  MyAppWeb.Gettext,
  "product",
  "product.created_info",
  user: product.creator.name,
  date: Calendar.strftime(product.inserted_at, "%Y-%m-%d"),
  time: Calendar.strftime(product.inserted_at, "%H:%M")
)
```

## Workflow Integration

### Development Workflow

```bash
# 1. Define translatable attributes in resource
# (Edit your resource file)

# 2. Extract msgids to .pot template
mix ash_phoenix_translations.extract --domain product

# 3. Merge with existing translations
mix gettext.merge priv/gettext --locale es

# 4. Edit .po files (manually or with tools)
# (Use Poedit, Weblate, or text editor)

# 5. Compile translations
mix compile.gettext

# 6. Restart development server
mix phx.server
```

### Translation Management Tools

**Poedit** - Desktop editor for .po files
```bash
# Open .po file
poedit priv/gettext/es/LC_MESSAGES/product.po
```

**Weblate** - Web-based collaborative translation
```yaml
# .weblate config
[weblate]
url = https://weblate.example.com
project = my_app
component = product_translations
file_format = po
```

**Lokalize** - KDE translation tool
```bash
lokalize priv/gettext/es/LC_MESSAGES/
```

### CI/CD Integration

```yaml
# .github/workflows/translations.yml
name: Translation Check

on: [push, pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2

      - name: Set up Elixir
        uses: erlef/setup-beam@v1
        with:
          elixir-version: 1.17
          otp-version: 27

      - name: Install dependencies
        run: mix deps.get

      - name: Extract translations
        run: mix ash_phoenix_translations.extract

      - name: Check for missing translations
        run: mix gettext.check

      - name: Compile translations
        run: mix compile.gettext
```

### Pre-commit Hooks

```bash
# .git/hooks/pre-commit
#!/bin/sh

echo "Extracting translations..."
mix ash_phoenix_translations.extract

echo "Merging translations..."
mix gettext.merge priv/gettext

echo "Compiling translations..."
mix compile.gettext

# Add changes
git add priv/gettext/**/*.po
```

## Advanced Features

### Fuzzy Matching

Mark translations needing review:

```po
#, fuzzy
msgid "product.name"
msgstr "Nombre del Producto"
```

When the source changes, mark as fuzzy to indicate review needed.

### Obsolete Translations

Keep old translations for reference:

```po
#~ msgid "product.old_field"
#~ msgstr "Campo Viejo"
```

These are ignored at runtime but preserved in .po files.

### Multi-line Translations

```po
msgid ""
"product.long_description"
msgstr ""
"Esta es una descripción muy larga "
"que abarca múltiples líneas y "
"se puede dividir para facilitar la lectura."
```

### Translation Notes

```po
# NOTE: This translation must match the legal terminology
# IMPORTANT: Do not translate the brand name
msgid "product.legal_notice"
msgstr "Aviso Legal de ProductBrand™"
```

## Troubleshooting

### Translations Not Appearing

**Symptom:** Changes to .po files don't show up

**Solutions:**

1. Recompile translations:
   ```bash
   mix compile.gettext --force
   ```

2. Restart development server:
   ```bash
   mix phx.server
   ```

3. Check locale configuration:
   ```elixir
   # config/config.exs
   config :my_app, MyAppWeb.Gettext,
     locales: ~w(en es fr)  # Ensure locale is listed
   ```

### Missing Message IDs

**Symptom:** `msgid not found` errors

**Solutions:**

1. Re-extract translations:
   ```bash
   mix ash_phoenix_translations.extract
   ```

2. Merge with existing:
   ```bash
   mix gettext.merge priv/gettext
   ```

3. Check resource configuration:
   ```elixir
   translations do
     backend :gettext  # Ensure backend is set
     gettext_module MyAppWeb.Gettext  # Module is required
   end
   ```

### Encoding Issues

**Symptom:** Special characters display incorrectly

**Solutions:**

1. Verify UTF-8 encoding:
   ```bash
   file -i priv/gettext/es/LC_MESSAGES/product.po
   # Should show: charset=utf-8
   ```

2. Convert if needed:
   ```bash
   iconv -f ISO-8859-1 -t UTF-8 product.po > product_utf8.po
   mv product_utf8.po product.po
   ```

3. Ensure header is correct:
   ```po
   "Content-Type: text/plain; charset=UTF-8\n"
   ```

### Pluralization Not Working

**Symptom:** Always shows same plural form

**Solutions:**

1. Check plural forms header:
   ```po
   "Plural-Forms: nplurals=2; plural=(n != 1);\n"
   ```

2. Verify msgid_plural exists:
   ```po
   msgid "product.count"
   msgid_plural "product.count_plural"  # Must have this
   msgstr[0] "..."
   msgstr[1] "..."
   ```

3. Use correct function:
   ```elixir
   # Use dngettext, not dgettext
   dngettext("product", "product.count", "product.count_plural", count, count: count)
   ```

### Gettext Module Not Found

**Symptom:** `module MyAppWeb.Gettext is not available`

**Solutions:**

1. Ensure Gettext is configured:
   ```elixir
   # lib/my_app_web/gettext.ex
   defmodule MyAppWeb.Gettext do
     use Gettext, otp_app: :my_app
   end
   ```

2. Add to resource configuration:
   ```elixir
   translations do
     backend :gettext
     gettext_module MyAppWeb.Gettext  # Must specify
   end
   ```

3. Verify in application supervision tree:
   ```elixir
   # lib/my_app/application.ex
   children = [
     MyAppWeb.Gettext,  # Should be here
     # ...
   ]
   ```

### Performance Issues

**Symptom:** Slow translation resolution

**Solutions:**

1. Enable caching:
   ```elixir
   translations do
     backend :gettext
     cache_ttl 3600  # Cache for 1 hour
   end
   ```

2. Compile translations in production:
   ```bash
   MIX_ENV=prod mix compile.gettext
   ```

3. Preload in development:
   ```elixir
   # config/dev.exs
   config :my_app, MyAppWeb.Gettext,
     default_locale: "en",
     prune_unmatched_locales: true  # Remove unused locales
   ```

## Best Practices

### 1. Consistent Domain Naming

Use clear, descriptive domain names:

```elixir
# Good
defmodule MyApp.Shop.Product do
  # domain: "product"
end

# Avoid
defmodule MyApp.P do
  # domain: "p" - unclear
end
```

### 2. Semantic Message IDs

Make msgids self-documenting:

```po
# Good
msgid "product.name"
msgid "product.description"

# Avoid
msgid "p1"
msgid "p2"
```

### 3. Translation Comments

Add context for translators:

```po
# TRANSLATORS: Brand name, do not translate
# CONTEXT: Displayed on product listing page
msgid "product.brand"
msgstr "MarcaEjemplo"
```

### 4. Version Control

Commit .po files, not .mo files:

```gitignore
# .gitignore
*.mo
priv/gettext/**/*.mo
```

### 5. Regular Extraction

Extract translations frequently:

```bash
# Add to development workflow
mix ash_phoenix_translations.extract && \
mix gettext.merge priv/gettext && \
git add priv/gettext/**/*.pot
```

### 6. Validation

Check completeness before release:

```bash
# Create validation script
mix run -e "AshPhoenixTranslations.validate_translations([:es, :fr])"
```

## Resources

- [Gettext Official Site](https://www.gnu.org/software/gettext/)
- [Phoenix Gettext Guide](https://hexdocs.pm/gettext/Gettext.html)
- [PO File Format Specification](https://www.gnu.org/software/gettext/manual/html_node/PO-Files.html)
- [Poedit Editor](https://poedit.net/)
- [Weblate Translation Platform](https://weblate.org/)
